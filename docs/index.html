<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Russian NOTAMs Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 15px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      font-size: 14px;
      max-width: 300px;
      z-index: 1000;
      overflow-y: auto;
      max-height: 80%;
    }

    .info-panel h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    .legend {
      line-height: 1.4em;
      margin-top: 5px;
    }

    /* Multi-feature selector popup styles */
    .multi-feature-popup {
      max-width: 350px;
    }

    .feature-selector {
      list-style: none;
      padding: 0;
      margin: 8px 0;
      max-height: 300px;
      overflow-y: auto;
    }

    .feature-selector li {
      padding: 8px 10px;
      margin: 4px 0;
      background: #f5f5f5;
      border-left: 4px solid #333;
      cursor: pointer;
      transition: background 0.2s;
    }

    .feature-selector li:hover {
      background: #e8e8e8;
    }

    .feature-selector .series-badge {
      display: inline-block;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      color: white;
      margin-right: 6px;
      font-size: 12px;
    }

    .feature-selector .feature-title {
      font-size: 13px;
    }

    .legend span {
      display: inline-block;
      width: 14px;
      height: 14px;
      margin-right: 6px;
      border-radius: 3px;
    }

    pre {
      white-space: pre-wrap;
      font-size: 13px;
    }

    /* Hide legend (series list) on narrow/mobile screens to maximize map space */
    @media (max-width: 640px) {
      .info-panel .legend {
        /* legendDiv */
        display: none;
      }

      .info-panel {
        max-width: 55%;
        font-size: 12px;
        padding: 8px 10px;
      }

      .info-panel h2 {
        font-size: 14px;
      }
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="info-panel">
    <h2 id="mapTitle">Russian NOTAMs</h2>
    <a href="https://www.caica.ru/ANI_Official/notam/notam_series/" style="font-size: xx-small;"
      target="_blank">source</a>
    <div class="legend" id="legend"></div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([60, 90], 3);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 12,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Available dataset layers
    const layers = ['A', 'C', 'G', 'L', 'P', 'Q', 'U', 'V', 'W', 'Z'];

    // Russian NOTAM series descriptions
    const notamSeriesExplained = {
      "A": "International NOTAMs of general interest (distributed worldwide via AFTN).",
      "C": "NOTAMs concerning route and enâ€‘route airspace structure.",
      "G": "GNSS, GPS, GLONASS, and satellite navigation NOTAMs.",
      "L": "Aerodrome lighting, visual aids, and equipment serviceability.",
      "P": "Air defense and restricted airspace activity.",
      "Q": "Navigation warnings and route structure changes.",
      "U": "Urgent operational NOTAMs (restrictions, emergencies).",
      "V": "State aviation NOTAMs of national significance.",
      "W": "Exercises, rocket launches, and space activities.",
      "Z": "Temporary segregated areas and other special activities."
    };

    // Colors for each series
    const seriesColors = {
      "A": "#1f77b4",
      "C": "#17becf",
      "G": "#2ca02c",
      "L": "#7f7f7f",
      "P": "#bcbd22",
      "Q": "#8c564b",
      "U": "#ff0000",
      "V": "#ff7f0e",
      "W": "#9467bd",
      "Z": "#e377c2"
    };

    // Legend
    const legendDiv = document.getElementById("legend");
    // Control bar (show all)
    const controlBar = document.createElement('div');
    controlBar.style.marginBottom = '6px';
    controlBar.innerHTML = '<button id="showAllBtn" style="margin-bottom:4px;">Show All</button><br/>';
    legendDiv.appendChild(controlBar);
    layers.forEach(series => {
      const color = seriesColors[series] || "#333";
      const div = document.createElement("div");
      div.className = 'legend-entry';
      div.dataset.series = series;
      div.innerHTML = `<span style="background:${color}"></span><b class="series-label" style="cursor:pointer;" title="Click to show only this layer">${series}</b>: ${notamSeriesExplained[series] || ''} <a href="#" class="solo-link" data-series="${series}" style="font-size:11px; margin-left:4px;">[only]</a><a href="${series}.geojson" download style="font-size:11px; margin-left:4px;" title="Download ${series}.geojson">[geojson]</a>`;
      legendDiv.appendChild(div);
    });

    // Layer storage
    const seriesLayers = {};
    // Store all layers with their feature data for overlap detection
    const allFeatureLayers = [];

    // Load each local GeoJSON file; show only selected series by default
    const defaultVisible = new Set(['G', 'L']);
    layers.forEach(series => {
      const group = L.layerGroup();
      if (defaultVisible.has(series)) {
        group.addTo(map);
      }
      seriesLayers[series] = group;

      fetch(`${series}.geojson`)
        .then(r => {
          if (!r.ok) throw new Error(`${series}.geojson not found`);
          return r.json();
        })
        .then(data => {
          L.geoJSON(data, {
            style: {
              color: seriesColors[series] || "#000",
              weight: 2,
              fillOpacity: 0.3
            },
            pointToLayer: (feature, latlng) => {
              return L.circleMarker(latlng, {
                radius: 6,
                color: seriesColors[series] || "#000",
                fillOpacity: 0.7
              });
            },
            onEachFeature: (feature, layer) => {
              // Store feature metadata with layer for later retrieval
              layer.featureData = { feature, series };
              allFeatureLayers.push({ layer, feature, series, group });

              // Create popup content but don't bind it yet (we'll handle clicks manually)
              layer.popupContent = createPopupContent(feature, series);
              
              // Disable default click behavior - we'll handle it in the map click handler
              layer.on('click', function(e) {
                L.DomEvent.stopPropagation(e);
              });
            }
          }).addTo(group);
        })
        .catch(err => console.warn(err.message));
    });

    // Layer control
    L.control.layers(null, seriesLayers, { collapsed: false }).addTo(map);

    // Create popup content for a feature
    function createPopupContent(feature, series) {
      const desc = notamSeriesExplained[series] || "Unknown series";
      const url = feature.properties?.url
        ? `<br><a href="${feature.properties.url}" target="_blank">Source</a>`
        : "";
      const text = feature.properties?.text
        ? `<pre>${feature.properties.text}</pre>`
        : "";
      return `
        <b>Series ${series}</b><br>
        <i style="font-size:smaller">${desc}</i>${url}<br>
        ${text}
        <button class="download-notam" style="margin-top:6px;">Download GeoJSON</button>
        <a class="link-yandex" target=_blank>Yandex Sat</a>
      `;
    }

    // Setup popup event handlers
    function setupPopupHandlers(popup, feature, series) {
      popup.on('add', () => {
        const el = popup.getElement();
        if (!el) return;
        const btn = el.querySelector('.download-notam');
        if (btn) {
          btn.addEventListener('click', () => downloadGeoJSON(feature, series), { once: true });
        }
        const href = el.querySelector('.link-yandex');
        if (href) {
          href.setAttribute("href", linkYandex(feature, series));
        }
      });
    }

    // Open a popup for a specific feature
    function openFeaturePopup(layer, feature, series, latlng) {
      const popup = L.popup({ maxWidth: 400 })
        .setLatLng(latlng)
        .setContent(layer.popupContent || createPopupContent(feature, series));
      
      setupPopupHandlers(popup, feature, series);
      popup.openOn(map);
    }

    // Handle map clicks to detect overlapping features
    // Point click tolerance in degrees (~55km at equator)
    const POINT_CLICK_TOLERANCE_DEGREES = 0.5;
    
    map.on('click', function(e) {
      // Find all features at the click point
      const clickedFeatures = [];
      const point = e.latlng;

      allFeatureLayers.forEach(({ layer, feature, series, group }) => {
        // Only check visible layers
        if (!map.hasLayer(group)) return;

        // Check if the click is within this feature
        let isInside = false;
        
        if (feature.geometry.type === 'Point') {
          const [lon, lat] = feature.geometry.coordinates;
          const distance = Math.sqrt(
            Math.pow(point.lat - lat, 2) + 
            Math.pow(point.lng - lon, 2)
          );
          isInside = distance < POINT_CLICK_TOLERANCE_DEGREES;
        } else if (feature.geometry.type === 'Polygon') {
          // Use precise point-in-polygon check
          const coords = feature.geometry.coordinates[0];
          isInside = pointInPolygon(point, coords);
        } else if (feature.geometry.type === 'MultiPolygon') {
          // Check each polygon in the MultiPolygon
          feature.geometry.coordinates.forEach(polygonCoords => {
            const coords = polygonCoords[0];
            if (pointInPolygon(point, coords)) {
              isInside = true;
            }
          });
        }

        if (isInside) {
          clickedFeatures.push({ layer, feature, series });
        }
      });

      // If multiple features found, show selector
      if (clickedFeatures.length > 1) {
        showFeatureSelector(clickedFeatures, point);
      } else if (clickedFeatures.length === 1) {
        // Single feature - open its popup directly
        const { layer, feature, series } = clickedFeatures[0];
        openFeaturePopup(layer, feature, series, point);
      }
      // If no features, do nothing (default Leaflet behavior)
    });

    // Point-in-polygon algorithm (ray casting)
    function pointInPolygon(point, coords) {
      let inside = false;
      const x = point.lng;
      const y = point.lat;

      for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
        const xi = coords[i][0];
        const yi = coords[i][1];
        const xj = coords[j][0];
        const yj = coords[j][1];

        const intersect = ((yi > y) !== (yj > y)) &&
          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }

      return inside;
    }

    // Show a selector popup when multiple features overlap
    function showFeatureSelector(features, latlng) {
      let html = '<div class="multi-feature-popup">';
      html += `<b>${features.length} overlapping features found</b><br>`;
      html += '<p style="font-size:12px;margin:4px 0;">Click on a feature to view details:</p>';
      html += '<ul class="feature-selector">';
      
      features.forEach((item, index) => {
        const { feature, series } = item;
        const color = seriesColors[series] || "#333";
        const title = feature.properties?.title || feature.properties?.text?.substring(0, 50) || 'Untitled';
        const displayTitle = title.length > 60 ? title.substring(0, 57) + '...' : title;
        
        html += `<li data-feature-index="${index}">`;
        html += `<span class="series-badge" style="background-color:${color}">Series ${series}</span>`;
        html += `<span class="feature-title">${displayTitle}</span>`;
        html += '</li>';
      });
      
      html += '</ul></div>';

      const popup = L.popup({ maxWidth: 400, className: 'multi-selector-popup' })
        .setLatLng(latlng)
        .setContent(html);

      // Add click handlers when popup is added to DOM
      popup.on('add', () => {
        const popupElement = popup.getElement();
        if (!popupElement) return;

        const items = popupElement.querySelectorAll('.feature-selector li');
        items.forEach((item, index) => {
          item.addEventListener('click', () => {
            map.closePopup(popup);
            // Open the selected feature's popup
            const { layer, feature, series } = features[index];
            openFeaturePopup(layer, feature, series, latlng);
          });
        });
      });

      popup.openOn(map);
    }

    // Helper functions to isolate or show all
    function showOnly(series) {
      layers.forEach(s => {
        const grp = seriesLayers[s];
        if (!grp) return;
        if (s === series) {
          if (!map.hasLayer(grp)) grp.addTo(map);
        } else {
          if (map.hasLayer(grp)) map.removeLayer(grp);
        }
      });
    }
    function showAll() {
      layers.forEach(s => {
        const grp = seriesLayers[s];
        if (grp && !map.hasLayer(grp)) grp.addTo(map);
      });
    }

    // Event delegation for legend entries
    legendDiv.addEventListener('click', (e) => {
      const soloAnchor = e.target.closest('a.solo-link');
      if (soloAnchor) {
        e.preventDefault();
        const series = soloAnchor.dataset.series;
        if (series) showOnly(series);
        return;
      }
      const label = e.target.closest('.series-label');
      if (label) {
        const parent = label.closest('.legend-entry');
        if (parent && parent.dataset.series) {
          showOnly(parent.dataset.series);
        }
      }
    });
    document.getElementById('showAllBtn').addEventListener('click', () => showAll());

    // Fetch timestamp and update title
    (function updateTitle() {
      const titleEl = document.getElementById('mapTitle');
      fetch("scrape_timestamp")
        .then(r => { if (!r.ok) throw new Error(); return r.text(); })
        .then(txt => {
          const date = txt.trim();
          if (date) {
            titleEl.textContent = `Russian NOTAMs, updated ${date}`;
          }
        })
        .catch(() => console.error("Failed to fetch timestamp"));
    })();

    // Download a single feature as GeoJSON
    function downloadGeoJSON(feature, series) {
      if (!feature) return;
      const fc = { type: 'FeatureCollection', features: [feature] };
      const id = (feature.properties && (feature.properties.notam_id || feature.properties.id)) || 'notam';
      const name = `notam_${series}_${id}.geojson`.replace(/[^A-Za-z0-9_.-]/g, '_');
      const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/geo+json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 500);
    }

    // Return a formatted link to yandex sat
    function linkYandex(feature, series) {
      if (!feature || !feature.geometry || !feature.geometry.coordinates) return;

      // Leaflet GeoJSON usually stores coordinates as [lon, lat]
      let coords = feature.geometry.coordinates;

      // Handle Point geometry vs Polygon/LineString (just take first point)
      let lon, lat;
      if (feature.geometry.type === "Point") {
        [lon, lat] = coords;
      } else if (Array.isArray(coords[0])) {
        [lon, lat] = coords[0][0]; // first coordinate pair
      }

      if (lat === undefined || lon === undefined) return;

      // Construct Yandex Maps satellite link
      const YANDEX_SAT = `https://yandex.com/maps/?l=sat&ll=${lon}%2C${lat}&z=17`;

      return YANDEX_SAT;
    }
  </script>
</body>

</html>