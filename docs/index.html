<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Russian NOTAMs Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 15px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      font-size: 14px;
      max-width: 300px;
      z-index: 1000;
      overflow-y: auto;
      max-height: 80%;
    }

    .info-panel h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    .legend {
      line-height: 1.4em;
      margin-top: 5px;
    }

    .legend span {
      display: inline-block;
      width: 14px;
      height: 14px;
      margin-right: 6px;
      border-radius: 3px;
    }

    pre {
      white-space: pre-wrap;
      font-size: 13px;
    }

    /* Hide legend (series list) on narrow/mobile screens to maximize map space */
    @media (max-width: 640px) {
      .info-panel .legend {
        /* legendDiv */
        display: none;
      }

      .info-panel {
        max-width: 55%;
        font-size: 12px;
        padding: 8px 10px;
      }

      .info-panel h2 {
        font-size: 14px;
      }
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="info-panel">
    <h2 id="mapTitle">Russian NOTAMs</h2>
    <a href="https://www.caica.ru/ANI_Official/notam/notam_series/" style="font-size: xx-small;"
      target="_blank">source</a>
    <div class="legend" id="legend"></div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([60, 90], 3);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 12,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Available dataset layers
    const layers = ['A', 'C', 'G', 'L', 'P', 'Q', 'U', 'V', 'W', 'Z'];

    // Russian NOTAM series descriptions
    const notamSeriesExplained = {
      "A": "International NOTAMs of general interest (distributed worldwide via AFTN).",
      "C": "NOTAMs concerning route and enâ€‘route airspace structure.",
      "G": "GNSS, GPS, GLONASS, and satellite navigation NOTAMs.",
      "L": "Aerodrome lighting, visual aids, and equipment serviceability.",
      "P": "Air defense and restricted airspace activity.",
      "Q": "Navigation warnings and route structure changes.",
      "U": "Urgent operational NOTAMs (restrictions, emergencies).",
      "V": "State aviation NOTAMs of national significance.",
      "W": "Exercises, rocket launches, and space activities.",
      "Z": "Temporary segregated areas and other special activities."
    };

    // Colors for each series
    const seriesColors = {
      "A": "#1f77b4",
      "C": "#17becf",
      "G": "#2ca02c",
      "L": "#7f7f7f",
      "P": "#bcbd22",
      "Q": "#8c564b",
      "U": "#ff0000",
      "V": "#ff7f0e",
      "W": "#9467bd",
      "Z": "#e377c2"
    };

    // Legend
    const legendDiv = document.getElementById("legend");
    // Control bar (show all)
    const controlBar = document.createElement('div');
    controlBar.style.marginBottom = '6px';
    controlBar.innerHTML = '<button id="showAllBtn" style="margin-bottom:4px;">Show All</button><br/>';
    legendDiv.appendChild(controlBar);
    layers.forEach(series => {
      const color = seriesColors[series] || "#333";
      const div = document.createElement("div");
      div.className = 'legend-entry';
      div.dataset.series = series;
      div.innerHTML = `<span style="background:${color}"></span><b class="series-label" style="cursor:pointer;" title="Click to show only this layer">${series}</b>: ${notamSeriesExplained[series] || ''} <a href="#" class="solo-link" data-series="${series}" style="font-size:11px; margin-left:4px;">[only]</a><a href="${series}.geojson" download style="font-size:11px; margin-left:4px;" title="Download ${series}.geojson">[geojson]</a>`;
      legendDiv.appendChild(div);
    });

    // Layer storage
    const seriesLayers = {};

    // Load each local GeoJSON file; show only selected series by default
    const defaultVisible = new Set(['G', 'L']);
    layers.forEach(series => {
      const group = L.layerGroup();
      if (defaultVisible.has(series)) {
        group.addTo(map);
      }
      seriesLayers[series] = group;

      fetch(`${series}.geojson`)
        .then(r => {
          if (!r.ok) throw new Error(`${series}.geojson not found`);
          return r.json();
        })
        .then(data => {
          L.geoJSON(data, {
            style: {
              color: seriesColors[series] || "#000",
              weight: 2,
              fillOpacity: 0.3
            },
            pointToLayer: (feature, latlng) => {
              return L.circleMarker(latlng, {
                radius: 6,
                color: seriesColors[series] || "#000",
                fillOpacity: 0.7
              });
            },
            onEachFeature: (feature, layer) => {
              const desc = notamSeriesExplained[series] || "Unknown series";
              const url = feature.properties?.url
                ? `<br><a href="${feature.properties.url}" target="_blank">Source</a>`
                : "";
              const text = feature.properties?.text
                ? `<pre>${feature.properties.text}</pre>`
                : "";
              layer.bindPopup(`
                <b>Series ${series}</b><br>
                <i style="font-size:smaller">${desc}</i>${url}<br>
                ${text}
                <button class="download-notam" style="margin-top:6px;">Download GeoJSON</button>
                <a class="link-yandex" target=_blank>Yandex Sat</a>
              `);
              layer.on('popupopen', (e) => {
                const el = e.popup.getElement();
                if (!el) return;
                const btn = el.querySelector('.download-notam');
                if (btn) {
                  btn.addEventListener('click', () => downloadGeoJSON(feature, series), { once: true });
                }
                const href = el.querySelector('.link-yandex');
                if (href) {
                  href.setAttribute("href", linkYandex(feature, series));
                }
              });
            }
          }).addTo(group);
        })
        .catch(err => console.warn(err.message));
    });

    // Layer control
    L.control.layers(null, seriesLayers, { collapsed: false }).addTo(map);

    // Helper functions to isolate or show all
    function showOnly(series) {
      layers.forEach(s => {
        const grp = seriesLayers[s];
        if (!grp) return;
        if (s === series) {
          if (!map.hasLayer(grp)) grp.addTo(map);
        } else {
          if (map.hasLayer(grp)) map.removeLayer(grp);
        }
      });
    }
    function showAll() {
      layers.forEach(s => {
        const grp = seriesLayers[s];
        if (grp && !map.hasLayer(grp)) grp.addTo(map);
      });
    }

    // Event delegation for legend entries
    legendDiv.addEventListener('click', (e) => {
      const soloAnchor = e.target.closest('a.solo-link');
      if (soloAnchor) {
        e.preventDefault();
        const series = soloAnchor.dataset.series;
        if (series) showOnly(series);
        return;
      }
      const label = e.target.closest('.series-label');
      if (label) {
        const parent = label.closest('.legend-entry');
        if (parent && parent.dataset.series) {
          showOnly(parent.dataset.series);
        }
      }
    });
    document.getElementById('showAllBtn').addEventListener('click', () => showAll());

    // Fetch timestamp and update title
    (function updateTitle() {
      const titleEl = document.getElementById('mapTitle');
      fetch("scrape_timestamp")
        .then(r => { if (!r.ok) throw new Error(); return r.text(); })
        .then(txt => {
          const date = txt.trim();
          if (date) {
            titleEl.textContent = `Russian NOTAMs, updated ${date}`;
          }
        })
        .catch(() => console.error("Failed to fetch timestamp"));
    })();

    // Download a single feature as GeoJSON
    function downloadGeoJSON(feature, series) {
      if (!feature) return;
      const fc = { type: 'FeatureCollection', features: [feature] };
      const id = (feature.properties && (feature.properties.notam_id || feature.properties.id)) || 'notam';
      const name = `notam_${series}_${id}.geojson`.replace(/[^A-Za-z0-9_.-]/g, '_');
      const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/geo+json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 500);
    }

    // Return a formatted link to yandex sat
    function linkYandex(feature, series) {
      if (!feature || !feature.geometry || !feature.geometry.coordinates) return;

      // Leaflet GeoJSON usually stores coordinates as [lon, lat]
      let coords = feature.geometry.coordinates;

      // Handle Point geometry vs Polygon/LineString (just take first point)
      let lon, lat;
      if (feature.geometry.type === "Point") {
        [lon, lat] = coords;
      } else if (Array.isArray(coords[0])) {
        [lon, lat] = coords[0][0]; // first coordinate pair
      }

      if (lat === undefined || lon === undefined) return;

      // Construct Yandex Maps satellite link
      const YANDEX_SAT = `https://yandex.com/maps/?l=sat&ll=${lon}%2C${lat}&z=17`;

      return YANDEX_SAT;
    }
  </script>
</body>

</html>